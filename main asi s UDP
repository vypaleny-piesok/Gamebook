import pygame
import sys
import random
import tkinter as tk
from tkinter import messagebox
import json


from network import UDPNetwork

# For testing, set one player as server, one as client
IS_SERVER = False # Set False for client
network = UDPNetwork(is_server=IS_SERVER)

chat_input = ""
chat_log = []
MAX_CHAT_LINES = 6


pygame.init()

# Screen
WIDTH, HEIGHT = 800, 600
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Dobrodru쬽tvo Gamebook")

# Fonts
FONT = pygame.font.Font("medieval.ttf", 28)
BIG_FONT = pygame.font.Font("medieval.ttf", 36)

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
LIGHT_GRAY = (220, 220, 220)
DARK_GRAY = (160, 160, 160)
RED = (200, 0, 0)
GREEN = (0, 200, 0)

# Background image and music
background_img = pygame.image.load("background_forest.jpg").convert()
background_img = pygame.transform.scale(background_img, (WIDTH, HEIGHT))

pygame.mixer.music.load("music.ogg")
pygame.mixer.music.play(-1)

# Icons
sword_icon = pygame.image.load("sword.png").convert_alpha()
sword_icon = pygame.transform.scale(sword_icon, (64, 64))
inventory_icon = pygame.image.load("inventory_icon.png").convert_alpha()
inventory_icon = pygame.transform.scale(inventory_icon, (48, 48))
leaf_img = pygame.image.load("leaf.png").convert_alpha()
leaf_img = pygame.transform.scale(leaf_img, (32, 32))

# Player stats
player_health = 100
coins = 0
inventory = ["Me캜"]
show_inventory = False

# Falling leaves setup (adjusted for fewer leaves)
leaves = []
for _ in range(random.randint(2, 4)):
    leaf = {
        "x": random.randint(0, WIDTH),
        "y": random.randint(-HEIGHT, 0),
        "speed": random.uniform(0.2, 0.6),
        "img": leaf_img
    }
    leaves.append(leaf)

# Typewriter effect variables
typed_text = ""
last_update_time = 0
text_char_index = 0
TEXT_SPEED = 30  # milliseconds per character

# Story node class
class StoryNode:
    def __init__(self, text, options, is_combat=False, enemy=None, coins=0):
        self.text = text
        self.options = options
        self.is_combat = is_combat
        self.enemy = enemy  # Dict like {"name": "Wolf", "health": 30}
        self.coins = coins  # New attribute to store coin rewards
        self.coins_collected = False


# Define story nodes
nodes = {
    "start": StoryNode(
        "Zobud칤코 sa v lese, tvoja hlava bol칤 a ni캜 si nepam칛t치코. Okolo teba je hust칳 les a vzduch je chladn칳. Pripad치코 si dezorientovan칳 a straten칳. Zrazu si uvedom칤코, 쬰 m치코 v ruk치ch krvav칳 me캜, ale v칪bec netu코칤코, odkia poch치dza. Kde si? 캛o sa stalo?",
        [
            {"text": "Sk칰si콘 si spomen칰콘, 캜o sa stalo", "next": "memory_lost"},
            {"text": "Presk칰ma콘 les", "next": "explore_forest"}
        ],
        coins=10  # Give 10 coins for this node
    ),
    "memory_lost": StoryNode(
        "Sna쮂솬 sa spomen칰콘 na nie캜o z minulosti, ale tvoje my코lienky s칰 roztrie코ten칠. C칤ti코 len z칰falstvo a chaos. Boles콘 v hlave sa zintenz칤v켿uje, ale nedok치쬰코 si vybavi콘 ni캜. Srdce ti bije r칳chlo. 캛o ak si niekto alebo nie캜o vymazalo tvoje spomienky?",
        [
            {"text": "Pok칰si콘 sa upokoji콘 a pokra캜ova콘 v h쬬dan칤 칰to캜i코콘a", "next": "find_shelter"},
            {"text": "Z칤ska콘 sa na chv칤쬿 a sedie콘", "next": "rest_under_tree"}
        ],
        coins = 5
    ),
    "explore_forest": StoryNode(
        "Kr치캜a코 캞alej lesom, ale 캜칤m viac sa dost치va코 do hlb코ieho lesa, t칳m viac sa c칤ti코 znepokojen칳. Kde sa nach치dza코? Zrazu po캜uje코 nie캜o 코uchota콘 v krov칤.",
        [
            {"text": "Skontrolova콘, 캜o je v krov칤", "next": "check_bush"},
            {"text": "Pokra캜ova콘 v ceste 캞alej", "next": "deeper_forest"}
        ],
        coins = 3
    ),
    "find_shelter": StoryNode(
        "Rozhodne코 sa h쬬da콘 칰to캜i코te predt칳m, ne sa zotmie. Po chv칤li n치jde코 mal칰 jasky켿u, kde sa m칪쬰코 skry콘. Je tam ticho a bezpe캜ne sa c칤ti코. Mo쬹o tu n치jde코 nejak칠 stopy o tom, 캜o sa stalo.",
        [
            {"text": "Presk칰ma콘 jasky켿u", "next": "cave_exploration"},
            {"text": "Odpo캜in칰콘 si a pok칰si콘 sa spomen칰콘", "next": "rest_under_tree"}
        ]
    ),
    "rest_under_tree": StoryNode(
        "Rozhodne코 sa sedie콘 pod stromom a upokoji콘 sa. Sna쮂솬 sa vypr치zdni콘 svoju myse, ale v tvojich my코lienkach st치le pretrv치va chaos. Zrazu zazrie코 nie캜o pohybuj칰ce sa medzi stromami.",
        [
            {"text": "Skontrolova콘, 캜o sa pohybuje medzi stromami", "next": "forest_figure"},
            {"text": "Pok칰si콘 sa op칛콘 z칤ska콘 kontrolu nad svojimi my코lienkami", "next": "memory_lost"}
        ]
    ),
    "check_bush": StoryNode(
        "Pod칤dete k krovu a zbad치te mal칰 zvieraciu stopu. Je to divok치 zver, ale nezjavuje sa. Mo쬹o ste sa na chv칤쬿 stratili v lese, alebo to m칪쬰 by콘 nie캜o nebezpe캜nej코ie.",
        [
            {"text": "Pokra캜ova콘 v h쬬dan칤 zviera콘a", "next": "hunt_animal"},
            {"text": "Vr치ti콘 sa k h쬬daniu 칰to캜i코콘a", "next": "find_shelter"}
        ]
    ),
    "deeper_forest": StoryNode(
        "Les sa e코te viac zhus콘uje. Vzduch je 콘a쬶칳 a vlhk칳. Na zemi sa objavuje stopy zviera콘a. Mo쬹o sa pribli쬿je코 k nie캜omu nebezpe캜n칠mu.",
        [
            {"text": "Pok칰si콘 sa sledova콘 stopy", "next": "follow_tracks"},
            {"text": "Zastavi콘 a presk칰ma콘 okolie", "next": "rest_under_tree"}
        ]
    ),
    "cave_exploration": StoryNode(
        "Jasky켿a je temn치 a vlhk치, ale zd치 sa, 쬰 tu niekto pred tebou niekedy bol. N치jde코 star칠, vyblednut칠 n치pisy na stene, ale nie s칰 zrozumite쬹칠.",
        [
            {"text": "Pok칰si콘 sa op칤sa콘 n치pisy", "next": "explore_forest"},
            {"text": "Opusti콘 jasky켿u a pokra캜ova콘 h쬬dan칤m", "next": "find_shelter"}
        ]
    ),
    "rest_under_tree": StoryNode(
        "Zrazu sa z lesa vytrhne zviera a r칳chlo sa rozbehne k tebe.",
        [
            {"text": "Bojova콘", "next": "fight_beast"},
            {"text": "Utiec콘", "next": "run_away"}
        ]
    ),
    "forest_figure": StoryNode(
        "Stoj칤코 a sleduje코, 캜o sa pohybuje medzi stromami. Zrazu zbad치코 postavu, ktor치 sa zd치 by콘 rovnak치 ako ty. Ale je to naozaj ty?",
        [
            {"text": "Pok칰si콘 sa oslovit postavu", "next": "speak_figure"},
            {"text": "Utiec콘 pred nezn치mou postavou", "next": "run_away"}
        ]
    ),
    "speak_figure": StoryNode(
        "Ke캞 sa pribl칤쬴코, postava zmizne. C칤ti코, 쬰 nie캜o nie je v poriadku.",
        [
            {"text": "Pokra캜ova콘 v h쬬dan칤 칰to캜i코콘a", "next": "find_shelter"},
            {"text": "Op칛콘 sk칰si콘 sa spomen칰콘, 캜o sa stalo", "next": "memory_lost"}
        ]
    ),
    "hunt_animal": StoryNode(
        "Chce코 sa pripravi콘 na lov, ale je to riskantn칠. Zvierat치 s칰 tu nebezpe캜n칠. Po chv칤li sa n치jde코 v konfront치cii s divok칳m medve캞om.",
        [
            {"text": "Bojova콘 s medve캞om", "next": "fight_bear"},
            {"text": "Utiec콘", "next": "run_away"}
        ]
    ),
    "follow_tracks": StoryNode(
        "Sleduje코 stopy a k rieke. Rieka je divok치 a nebezpe캜n치, ale mo쬹o sa ti podar칤 prejs콘.",
        [
            {"text": "Pok칰si콘 sa prejs콘 rieku", "next": "cross_river"},
            {"text": "Vr치ti콘 sa sp칛콘 a presk칰ma콘 les", "next": "explore_forest"}
        ]
    ),
    "fight_bear": StoryNode(
    "Boj s medve캞om je drsn칳 a vy캜erp치vaj칰ci. Po tvrd칳ch 칰deroch medve캞 ust칰pi, ale je to 콘a쬶치 v칳hra. M치코 ve쬬 r치n.",
    [
        {"text": "Pokra캜ova콘 캞alej", "next": "end"}
    ],
    is_combat=True,  # Nastaven칠 na True, aby sa zapol syst칠m boja
    enemy={"name": "Medve캞", "health": 50}  # Definovanie nepriate쬬, ktor칳 bude pou쬴t칳 pri boji
),
    "fight_beast": StoryNode(
        "Bojoval si stato캜ne, ale zviera 콘a porazilo. Boles콘 je neznesite쬹치, a ty pad치코 na zem.",
        [
            {"text": "Zomrel si", "next": "end"}
        ]
    ),
    "cross_river": StoryNode(
        "Prejdenie rieky bolo 콘a쬶칠, ale nakoniec sa ti podarilo. Na druhej strane n치jde코 nie캜o nezn치me, ale nie캜o, 캜o ti m칪쬰 pom칪c콘 v ceste.",
        [
            {"text": "Presk칰ma콘 nezn치mu oblas콘", "next": "unknown_area"},
            {"text": "Pokra캜ova콘 v ceste", "next": "explore_forest"}
        ]
    ),
    "run_away": StoryNode(
        "U코iel si do bezpe캜ia, ale si zranen칳 a unaven칳.",
        [
            {"text": "Pokra캜ova콘 v ceste", "next": "explore_forest"}
        ]
    ),
    "unknown_area": StoryNode(
        "Dostal si sa do nezn치mej oblasti. Tu to vyzer치 inak. C칤ti코, 쬰 sa nie캜o zmenilo.",
        [
            {"text": "Presk칰ma콘 oblas콘", "next": "explore_forest"},
            {"text": "Pok칰si콘 sa n치js콘 pomoc", "next": "find_shelter"}
        ]
    ),
    "end": StoryNode(
        "Tvoje dobrodru쬽tvo pokra캜uje... a do 캞al코ieho d켿a.",
        []
    )
}



current_node = "start"

# Combat logic variables
in_combat = False
enemy = None
combat_log = []


def save_game():
    game_state = {
        'current_node': current_node,
        'inventory': inventory,
        'health': player_health
    }
    with open("savefile.json", "w") as f:
        json.dump(game_state, f)
    messagebox.showinfo("Game Saved", "Your progress has been saved!")

def load_game():
    global current_node, inventory, player_health, typed_text, text_char_index
    try:
        with open("savefile.json", "r") as f:
            game_state = json.load(f)
            current_node = game_state.get('current_node', 'start')
            inventory = game_state.get('inventory', [])
            player_health = game_state.get('health', 100)

            # Reset typewriter state
            node = nodes[current_node]
            typed_text = ""
            text_char_index = 0
            messagebox.showinfo("Game Loaded", "Your progress has been loaded!")
    except FileNotFoundError:
        messagebox.showwarning("Load Failed", "No saved game found.")


# Draw outlined text
def draw_text(text, x, y, max_width=700):
    words = text.split()
    line = ""
    y_offset = 0
    for word in words:
        if FONT.size(line + word)[0] > max_width:
            draw_outline_text(line.strip(), x, y + y_offset)
            y_offset += 35
            line = ""
        line += word + " "
    draw_outline_text(line.strip(), x, y + y_offset)

def draw_outline_text(text, x, y):
    for dx in [-1, 0, 1]:
        for dy in [-1, 0, 1]:
            if dx != 0 or dy != 0:
                screen.blit(FONT.render(text, True, BLACK), (x + dx, y + dy))
    screen.blit(FONT.render(text, True, WHITE), (x, y))

def draw_inventory():
    if show_inventory:
        inv_x, inv_y = WIDTH - 210, 60
        inv_width, inv_height = 200, 100
        pygame.draw.rect(screen, (30, 30, 30), (inv_x, inv_y, inv_width, inv_height), border_radius=8)
        pygame.draw.rect(screen, WHITE, (inv_x, inv_y, inv_width, inv_height), 2, border_radius=8)

        padding = 10
        icon_size = 40
        spacing = 50
        for idx, item in enumerate(inventory):
            item_x = inv_x + padding + (idx % 4) * spacing
            item_y = inv_y + padding + (idx // 4) * spacing
            if item == "Me캜":
                icon_rect = screen.blit(pygame.transform.scale(sword_icon, (icon_size, icon_size)), (item_x, item_y))
                if icon_rect.collidepoint(pygame.mouse.get_pos()):
                    draw_outline_text(item, item_x, item_y + icon_size + 5)

def draw_health():
    pygame.draw.rect(screen, RED, (20, 20, 200, 25))
    pygame.draw.rect(screen, GREEN, (20, 20, max(0, player_health) * 2, 25))
    draw_outline_text(f"Zdravie: {player_health}", 230, 20)

def damage_flash():
    flash_surface = pygame.Surface((WIDTH, HEIGHT))
    flash_surface.set_alpha(120)
    flash_surface.fill((255, 0, 0))
    screen.blit(flash_surface, (0, 0))
    pygame.display.flip()
    pygame.time.delay(150)

def item_flash():
    flash_surface = pygame.Surface((WIDTH, HEIGHT))
    flash_surface.set_alpha(100)
    flash_surface.fill((0, 255, 0))
    screen.blit(flash_surface, (0, 0))
    pygame.display.flip()
    pygame.time.delay(150)

def fade_transition():
    fade = pygame.Surface((WIDTH, HEIGHT))
    fade.fill((0, 0, 0))
    for alpha in range(0, 255, 15):
        fade.set_alpha(alpha)
        screen.blit(fade, (0, 0))
        pygame.display.flip()
        pygame.time.delay(30)

def draw_leaves():
    for leaf in leaves:
        screen.blit(leaf["img"], (leaf["x"], leaf["y"]))
        leaf["y"] += leaf["speed"]
        if leaf["y"] > HEIGHT:
            leaf["y"] = random.randint(-HEIGHT, -20)
            leaf["x"] = random.randint(0, WIDTH)

def go_to_next_node(next_node):
    global current_node, player_coins
    # Get the next node
    current_node = next_node
    node = nodes[current_node]

    # Add coins from the current node
    player_coins += node.coins

    # Your existing logic to handle the transition to the new node, including story text and options.
    print(f"Coins: {player_coins}")  # Display the updated coin count for testing


# Typewriter logic
def update_typed_text(full_text, current_time):
    global typed_text, text_char_index, last_update_time
    if text_char_index < len(full_text):
        if current_time - last_update_time > TEXT_SPEED:
            typed_text += full_text[text_char_index]
            text_char_index += 1
            last_update_time = current_time

root = tk.Tk()
root.withdraw()  # Hides the root window but allows messageboxes

def main():
    global current_node, player_health, show_inventory
    global typed_text, text_char_index
    global chat_input, chat_log, in_combat, enemy, combat_log
    global coins  # Add this line to reference the global coins variable

    clock = pygame.time.Clock()

    while True:
        screen.blit(background_img, (0, 0))
        draw_leaves()

        node = nodes[current_node]

        # Only collect coins if not already collected for this node
        if not node.coins_collected:
            coins += node.coins  # Add coins for this node
            node.coins_collected = True  # Mark coins as collected for this node

        update_typed_text(node.text, pygame.time.get_ticks())
        draw_text(typed_text, 20, 80)
        draw_health()
        draw_inventory()

        # Draw chat box
        pygame.draw.rect(screen, (50, 50, 50), (10, HEIGHT - 170, 780, 160))
        for i, msg in enumerate(chat_log[-MAX_CHAT_LINES:]):
            draw_outline_text(msg, 20, HEIGHT - 160 + i * 25)

        # Draw chat input
        pygame.draw.rect(screen, WHITE, (10, HEIGHT - 30, 780, 25))
        draw_outline_text("> " + chat_input, 15, HEIGHT - 28)

        # Draw the coins at the top-left of the screen
        draw_outline_text(f"Coins: {coins}", 600, 20)

        mouse = pygame.mouse.get_pos()
        click = False
        # Save button (draw it)
        save_button_rect = pygame.Rect(WIDTH - 150, HEIGHT - 50, 120, 35)
        pygame.draw.rect(screen, DARK_GRAY if save_button_rect.collidepoint(mouse) else LIGHT_GRAY, save_button_rect,
                         border_radius=8)
        draw_outline_text("游 Ulo쬴콘", save_button_rect.x + 10, save_button_rect.y + 5)
        load_button_rect = pygame.Rect(WIDTH - 280, HEIGHT - 50, 120, 35)
        pygame.draw.rect(screen, DARK_GRAY if load_button_rect.collidepoint(mouse) else LIGHT_GRAY, load_button_rect,
                         border_radius=8)
        draw_outline_text("游늭 Na캜칤ta콘", load_button_rect.x + 10, load_button_rect.y + 5)

        # Receive chat or game state
        for addr, msg in network.get_messages():
            if msg.startswith("chat:"):
                chat_log.append("Them: " + msg[5:])

        for event in pygame.event.get():
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    if chat_input.strip():
                        chat_log.append("You: " + chat_input)
                        network.send("chat:" + chat_input)
                        chat_input = ""
                elif event.key == pygame.K_BACKSPACE:
                    chat_input = chat_input[:-1]
                else:
                    chat_input += event.unicode

            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                click = True

                node = nodes[current_node]
                # Instantly reveal all text (skip typewriter effect)
                typed_text = node.text
                text_char_index = len(node.text)

                # Toggle inventory if icon is clicked
                if inventory_icon_rect.collidepoint(mouse):
                    show_inventory = not show_inventory
                if save_button_rect.collidepoint(mouse):
                    save_game()
                if load_button_rect.collidepoint(mouse):
                    load_game()

        # Inventory icon
        inventory_icon_rect = screen.blit(inventory_icon, (WIDTH - 60, 30))

        if node.is_combat:
            in_combat = True
            if enemy is None:
                enemy = dict(node.enemy)  # Copy the enemy
                combat_log = []

            # Display enemy and combat log
            draw_outline_text(f"{enemy['name']} - HP: {enemy['health']}", 50, 260)
            for i, log in enumerate(combat_log[-3:]):
                draw_outline_text(log, 50, 290 + i * 25)

            # Combat options
            combat_choices = [
                {"text": "칔tok", "action": "attack"},
                {"text": "칔tek", "action": "flee"},
                {"text": "맗eci치lny 칰tok", "action": "special"}
            ]
            for i, option in enumerate(combat_choices):
                btn_rect = pygame.Rect(50, 400 + i * 50, 700, 45)
                color = DARK_GRAY if btn_rect.collidepoint(mouse) else LIGHT_GRAY
                pygame.draw.rect(screen, color, btn_rect, border_radius=8)
                pygame.draw.rect(screen, BLACK, btn_rect, 2, border_radius=8)
                draw_outline_text(option["text"], btn_rect.x + 10, btn_rect.y + 10)

                if btn_rect.collidepoint(mouse) and click:
                    result_text = ""
                    if option["action"] == "attack":
                        dmg = random.randint(5, 15)
                        enemy["health"] -= dmg
                        result_text = f"Zasiahol si nepriate쬬 za {dmg} HP."
                    elif option["action"] == "flee":
                        player_health -= 10
                        result_text = "Utiekol si, ale si zranen칳 za 10 HP."
                        current_node = "run_away"
                        fade_transition()
                        typed_text = ""
                        text_char_index = 0
                        enemy = None
                        in_combat = False
                        break
                    elif option["action"] == "special":
                        if random.random() < 0.3:  # 30% chance
                            dmg = random.randint(20, 30)
                            enemy["health"] -= dmg
                            result_text = f"맗eci치lny 칰tok uspel! {dmg} HP!"
                        else:
                            player_health -= 5
                            result_text = "맗eci치lny 칰tok zlyhal. Stratil si 5 HP."

                    # Enemy attacks back if alive
                    if enemy["health"] > 0 and option["action"] != "flee":
                        enemy_dmg = random.randint(5, 12)
                        player_health -= enemy_dmg
                        result_text += f" {enemy['name']} za칰to캜il za {enemy_dmg} HP."

                    combat_log.append(result_text)

                    # Check if enemy is dead
                    if enemy["health"] <= 0:
                        current_node = "end"
                        fade_transition()
                        typed_text = ""
                        text_char_index = 0
                        enemy = None
                        in_combat = False
                        break

        # Draw normal story options
        if text_char_index >= len(node.text) and not node.is_combat:
            for i, option in enumerate(node.options):
                btn_rect = pygame.Rect(50, 300 + i * 60, 700, 45)
                color = DARK_GRAY if btn_rect.collidepoint(mouse) else LIGHT_GRAY
                pygame.draw.rect(screen, color, btn_rect, border_radius=8)
                pygame.draw.rect(screen, BLACK, btn_rect, 2, border_radius=8)
                draw_outline_text(option["text"], btn_rect.x + 10, btn_rect.y + 10)

                if btn_rect.collidepoint(mouse) and click:
                    if "health_change" in option:
                        change = option["health_change"]
                        if change < 0:
                            damage_flash()
                        player_health += change
                    if "item" in option:
                        inventory.append(option["item"])
                        item_flash()

                    fade_transition()
                    current_node = option["next"]

                    # Reset typewriter
                    typed_text = ""
                    text_char_index = 0
                    break

        pygame.display.flip()
        clock.tick(60)

main()
